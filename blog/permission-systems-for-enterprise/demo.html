<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Permission Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --base00: #181818;
        --base01: #282828;
        --base02: #383838;
        --base03: #585858;
        --base04: #b8b8b8;
        --base05: #d8d8d8;
        --base06: #e8e8e8;
        --base07: #f8f8f8;
        --base08: #ab4642;
        --base09: #dc9656;
        --base0A: #f7ca88;
        --base0B: #a1b56c;
        --base0C: #86c1b9;
        --base0D: #7cafc2;
        --base0E: #ba8baf;
        --base0F: #a16946;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "JetBrains Mono", monospace;
        font-weight: 400;
        line-height: 1.6;
        color: var(--base05);
        background-color: var(--base00);
        padding: 1rem;
      }

      .demo-container {
        max-width: 600px;
        margin: 0 auto;
        border: 1px solid var(--base02);
        border-radius: 8px;
        overflow: hidden;
      }

      /* Tabs */
      .tabs {
        display: flex;
        background-color: var(--base01);
        border-bottom: 1px solid var(--base02);
        overflow-x: auto;
      }

      .tab {
        padding: 0.75rem 1.25rem;
        background: none;
        border: none;
        color: var(--base04);
        font-family: "JetBrains Mono", monospace;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        white-space: nowrap;
        transition:
          color 0.2s ease,
          border-color 0.2s ease;
      }

      .tab:hover {
        color: var(--base05);
      }

      .tab.active {
        color: var(--base08);
        border-bottom-color: var(--base08);
      }

      .tab.add-user {
        color: var(--base0D);
        margin-left: auto;
      }

      .tab.add-user:hover {
        color: var(--base0C);
      }

      /* Controls */
      .controls {
        padding: 1rem;
        background-color: var(--base01);
        border-bottom: 1px solid var(--base02);
      }

      .user-type {
        display: flex;
        gap: 1.5rem;
        margin-bottom: 1rem;
      }

      .user-type label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        font-size: 0.95rem;
      }

      .user-type input[type="radio"] {
        appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid var(--base03);
        border-radius: 50%;
        cursor: pointer;
        position: relative;
      }

      .user-type input[type="radio"]:checked {
        border-color: var(--base0D);
      }

      .user-type input[type="radio"]:checked::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 8px;
        height: 8px;
        background-color: var(--base0D);
        border-radius: 50%;
      }

      .actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .btn {
        padding: 0.5rem 1rem;
        background-color: var(--base01);
        border: 2px solid var(--base03);
        border-radius: 4px;
        color: var(--base07);
        font-family: "JetBrains Mono", monospace;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      .btn:hover:not(:disabled) {
        border-color: var(--base0D);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Share dropdown */
      .share-container {
        position: relative;
        display: inline-block;
      }

      .share-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0.25rem;
        background-color: var(--base01);
        border: 1px solid var(--base03);
        border-radius: 4px;
        min-width: 150px;
        z-index: 100;
        display: none;
      }

      .share-dropdown.open {
        display: block;
      }

      .share-option {
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background-color 0.2s ease;
      }

      .share-option:hover {
        background-color: var(--base02);
      }

      .share-option.new-user {
        border-top: 1px solid var(--base02);
        color: var(--base0D);
      }

      /* Tree */
      .tree {
        padding: 1rem;
        min-height: 200px;
        background-color: var(--base00);
      }

      .tree-item {
        padding: 0.4rem 0.75rem;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
        transition: background-color 0.2s ease;
      }

      .tree-item:hover {
        background-color: var(--base01);
      }

      .tree-item.selected {
        background-color: var(--base02);
      }

      .tree-item .icon {
        flex-shrink: 0;
      }

      .tree-item .name {
        flex: 1;
      }

      .tree-item .shared-badge {
        font-size: 0.75rem;
        color: var(--base0B);
        background-color: var(--base01);
        padding: 0.1rem 0.4rem;
        border-radius: 3px;
      }

      .tree-children {
        margin-left: 1.25rem;
      }

      .empty-message {
        color: var(--base03);
        font-style: italic;
        padding: 1rem;
        text-align: center;
      }

      /* Status bar */
      .status-bar {
        display: flex;
        gap: 1rem;
        padding: 0.5rem 1rem;
        background-color: var(--base01);
        border-top: 1px solid var(--base02);
        font-size: 0.75rem;
        color: var(--base04);
        flex-wrap: wrap;
        align-items: center;
      }

      .status-bar .stat {
        display: flex;
        gap: 0.25rem;
      }

      .status-bar .stat-value {
        color: var(--base0D);
      }

      .status-bar .stat-value.rbac {
        color: var(--base0B);
      }

      .impl-toggle {
        margin-left: auto;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .impl-toggle label {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        cursor: pointer;
      }

      .impl-toggle input[type="radio"] {
        appearance: none;
        width: 12px;
        height: 12px;
        border: 2px solid var(--base03);
        border-radius: 50%;
        cursor: pointer;
        position: relative;
      }

      .impl-toggle input[type="radio"]:checked {
        border-color: var(--base0D);
      }

      .impl-toggle input[type="radio"]:checked::after {
        content: "";
        position: absolute;
        top: 1px;
        left: 1px;
        width: 6px;
        height: 6px;
        background-color: var(--base0D);
        border-radius: 50%;
      }

      @media (max-width: 768px) {
        body {
          padding: 0.5rem;
        }

        .tab {
          padding: 0.6rem 1rem;
          font-size: 0.85rem;
        }

        .controls {
          padding: 0.75rem;
        }

        .user-type {
          gap: 1rem;
        }

        .btn {
          padding: 0.4rem 0.75rem;
          font-size: 0.8rem;
        }

        .status-bar {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.5rem;
        }

        .impl-toggle {
          margin-left: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="demo-container">
      <div class="tabs" id="tabs"></div>
      <div class="controls">
        <div class="user-type" id="userType"></div>
        <div class="actions" id="actions"></div>
      </div>
      <div class="tree" id="tree"></div>
      <div class="status-bar" id="statusBar">
        <div class="stat">
          reads: <span class="stat-value" id="statReads">0</span>
        </div>
        <div class="stat">
          writes: <span class="stat-value" id="statWrites">0</span>
        </div>
        <div class="stat">
          scanned: <span class="stat-value" id="statScanned">0</span>
        </div>
        <div class="impl-toggle">
          <label>
            <input type="radio" name="impl" value="naive" checked />
            Naive
          </label>
          <label>
            <input type="radio" name="impl" value="rbac" />
            RBAC
          </label>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/sql-wasm.min.js"></script>
    <script>
      // Configuration
      const DB_THROTTLE_MS = 10;

      // Current implementation mode
      let implementationMode = "naive";

      // Stats tracking (per minute)
      const stats = { reads: 0, writes: 0, scanned: 0 };
      let statsStartTime = Date.now();

      function resetStatsIfNeeded() {
        const now = Date.now();
        if (now - statsStartTime >= 60000) {
          stats.reads = 0;
          stats.writes = 0;
          stats.scanned = 0;
          statsStartTime = now;
        }
      }

      function updateStatsDisplay() {
        resetStatsIfNeeded();
        const statValueClass =
          implementationMode === "rbac" ? "stat-value rbac" : "stat-value";
        document.getElementById("statReads").className = statValueClass;
        document.getElementById("statWrites").className = statValueClass;
        document.getElementById("statScanned").className = statValueClass;
        document.getElementById("statReads").textContent = stats.reads;
        document.getElementById("statWrites").textContent = stats.writes;
        document.getElementById("statScanned").textContent = stats.scanned;
      }

      // Throttle helper to simulate network latency
      function throttle() {
        return new Promise((resolve) => setTimeout(resolve, DB_THROTTLE_MS));
      }

      // SQLite database
      let db;

      async function initSQL() {
        const SQL = await initSqlJs({
          locateFile: (file) =>
            `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/${file}`,
        });
        db = new SQL.Database();

        // Create tables
        db.run(`
          CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            type TEXT NOT NULL DEFAULT 'standard'
          )
        `);

        db.run(`
          CREATE TABLE resources (
            id INTEGER PRIMARY KEY,
            type TEXT NOT NULL,
            name TEXT NOT NULL,
            parent_id INTEGER,
            owner_id INTEGER NOT NULL,
            ancestor_path TEXT DEFAULT '',
            FOREIGN KEY (parent_id) REFERENCES resources(id),
            FOREIGN KEY (owner_id) REFERENCES users(id)
          )
        `);

        db.run(`
          CREATE TABLE shares (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            resource_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            FOREIGN KEY (resource_id) REFERENCES resources(id),
            FOREIGN KEY (user_id) REFERENCES users(id),
            UNIQUE(resource_id, user_id)
          )
        `);

        db.run(`
          CREATE TABLE counters (
            id TEXT PRIMARY KEY,
            folder_count INTEGER DEFAULT 1,
            file_count INTEGER DEFAULT 0,
            user_count INTEGER DEFAULT 1,
            resource_count INTEGER DEFAULT 1
          )
        `);

        // RBAC: Pre-computed permissions (junction table for O(1) access checks)
        // access_type: 'owner' (full control), 'shared' (read only), 'path_only' (visible but no access)
        db.run(`
          CREATE TABLE permissions (
            user_id INTEGER NOT NULL,
            resource_id INTEGER NOT NULL,
            access_type TEXT NOT NULL DEFAULT 'path_only',
            PRIMARY KEY (user_id, resource_id),
            FOREIGN KEY (user_id) REFERENCES users(id),
            FOREIGN KEY (resource_id) REFERENCES resources(id)
          )
        `);

        // Create indexes for faster queries
        db.run(`CREATE INDEX idx_resources_parent ON resources(parent_id)`);
        db.run(`CREATE INDEX idx_resources_owner ON resources(owner_id)`);
        db.run(`CREATE INDEX idx_shares_resource ON shares(resource_id)`);
        db.run(`CREATE INDEX idx_shares_user ON shares(user_id)`);
        db.run(`CREATE INDEX idx_permissions_user ON permissions(user_id)`);
      }

      // SQL helper functions with stats tracking
      async function sqlQuery(sql, params = []) {
        await throttle();
        stats.reads++;
        updateStatsDisplay();

        const result = db.exec(sql, params);
        if (result.length === 0) return [];

        const columns = result[0].columns;
        const rows = result[0].values.map((row) => {
          const obj = {};
          columns.forEach((col, i) => (obj[col] = row[i]));
          return obj;
        });

        stats.scanned += rows.length;
        updateStatsDisplay();
        return rows;
      }

      async function sqlQueryOne(sql, params = []) {
        const rows = await sqlQuery(sql, params);
        return rows[0] || null;
      }

      async function sqlRun(sql, params = []) {
        await throttle();
        stats.writes++;
        updateStatsDisplay();
        db.run(sql, params);
      }

      function sqlRunSync(sql, params = []) {
        db.run(sql, params);
      }

      // UI State
      let activeUserId = 1;
      let selectedResourceId = 1;

      // Cache for rendering (avoid DB queries on selection change)
      let cache = {
        users: [],
        resources: [],
        shares: [],
        visibleIds: [],
        permissions: {}, // RBAC: { resourceId: 'owner' | 'shared' | 'path_only' }
        dirty: true,
      };

      // DOM elements
      const tabsEl = document.getElementById("tabs");
      const userTypeEl = document.getElementById("userType");
      const actionsEl = document.getElementById("actions");
      const treeEl = document.getElementById("tree");

      // Helper to parse ancestor_path string into array of IDs
      function parseAncestorPath(path) {
        if (!path) return [];
        return path.split(",").filter(Boolean).map(Number);
      }

      // RBAC: Grant permission for a new resource to its owner
      async function grantPermissionOnCreate(resourceId, ownerId) {
        await sqlRun(
          `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'owner')`,
          [ownerId, resourceId],
        );
      }

      // RBAC: Grant permissions when sharing a resource
      // - Shared resource + descendants: 'shared' (read access)
      // - Ancestors: 'path_only' (visible but no access)
      async function grantPermissionsOnShare(resourceId, userId) {
        const resource = await sqlQueryOne(
          `SELECT id, ancestor_path FROM resources WHERE id = ?`,
          [resourceId],
        );

        // Add the shared resource itself with 'shared' access
        await sqlRun(
          `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
          [userId, resourceId],
        );

        // Add ancestors for path visibility (path_only - no actual access)
        const ancestorIds = parseAncestorPath(resource.ancestor_path);
        for (const ancestorId of ancestorIds) {
          await sqlRun(
            `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'path_only')`,
            [userId, ancestorId],
          );
        }

        // Add all descendants with 'shared' access
        const descendants = await sqlQuery(
          `
          WITH RECURSIVE tree AS (
            SELECT id FROM resources WHERE parent_id = ?
            UNION ALL
            SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
          )
          SELECT id FROM tree
        `,
          [resourceId],
        );
        for (const desc of descendants) {
          await sqlRun(
            `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
            [userId, desc.id],
          );
        }
      }

      // RBAC: Full rebuild of permissions (used when user type changes)
      async function rebuildUserPermissions(userId) {
        // Clear existing permissions
        await sqlRun(`DELETE FROM permissions WHERE user_id = ?`, [userId]);

        const user = await sqlQueryOne(`SELECT * FROM users WHERE id = ?`, [
          userId,
        ]);

        if (user.type === "admin") {
          // Admin has 'owner' access to everything
          await sqlRun(
            `INSERT INTO permissions (user_id, resource_id, access_type)
             SELECT ?, id, 'owner' FROM resources`,
            [userId],
          );
          return;
        }

        // Standard user: owned resources + descendants get 'owner' access
        const ownedAndDescendants = await sqlQuery(
          `
          WITH RECURSIVE owned_tree AS (
            SELECT id FROM resources WHERE owner_id = ?
            UNION ALL
            SELECT r.id FROM resources r
            JOIN owned_tree ot ON r.parent_id = ot.id
          )
          SELECT id FROM owned_tree
        `,
          [userId],
        );
        for (const r of ownedAndDescendants) {
          await sqlRun(
            `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'owner')`,
            [userId, r.id],
          );
        }

        // Standard user: shared resources + ancestors + descendants
        const sharedResources = await sqlQuery(
          `
          SELECT r.id, r.ancestor_path
          FROM shares s
          JOIN resources r ON s.resource_id = r.id
          WHERE s.user_id = ?
        `,
          [userId],
        );

        for (const resource of sharedResources) {
          // Shared resource gets 'shared' access
          await sqlRun(
            `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
            [userId, resource.id],
          );

          // Ancestors get 'path_only' access
          for (const ancestorId of parseAncestorPath(resource.ancestor_path)) {
            await sqlRun(
              `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'path_only')`,
              [userId, ancestorId],
            );
          }

          // Descendants get 'shared' access
          const descendants = await sqlQuery(
            `
            WITH RECURSIVE tree AS (
              SELECT id FROM resources WHERE parent_id = ?
              UNION ALL
              SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
            )
            SELECT id FROM tree
          `,
            [resource.id],
          );
          for (const desc of descendants) {
            await sqlRun(
              `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
              [userId, desc.id],
            );
          }
        }
      }

      // Get visible resource IDs - different implementation based on mode
      async function getVisibleResourceIds(userId) {
        if (implementationMode === "rbac") {
          // RBAC: Single query to get pre-computed permissions via JOIN
          const permissions = await sqlQuery(
            `SELECT resource_id FROM permissions WHERE user_id = ?`,
            [userId],
          );
          return permissions.map((p) => p.resource_id);
        }

        // ==========================================
        // NAIVE IMPLEMENTATION - Multiple queries
        // This demonstrates the N+1 query problem
        // ==========================================

        const user = await sqlQueryOne(`SELECT * FROM users WHERE id = ?`, [
          userId,
        ]);

        if (user.type === "admin") {
          // Admin: Fetch all resources
          const allResources = await sqlQuery(`SELECT id FROM resources`);
          return allResources.map((r) => r.id);
        }

        const visibleIds = new Set();

        // Query 1: Get owned resources
        const ownedResources = await sqlQuery(
          `SELECT id FROM resources WHERE owner_id = ?`,
          [userId],
        );

        // N+1 Problem: For each owned resource, fetch descendants recursively
        for (const resource of ownedResources) {
          visibleIds.add(resource.id);

          // Recursive query for each owned resource
          const descendants = await sqlQuery(
            `
            WITH RECURSIVE tree AS (
              SELECT id FROM resources WHERE parent_id = ?
              UNION ALL
              SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
            )
            SELECT id FROM tree
          `,
            [resource.id],
          );
          descendants.forEach((r) => visibleIds.add(r.id));
        }

        // Query 2: Get resources shared with user
        const sharedResources = await sqlQuery(
          `
          SELECT r.id, r.ancestor_path
          FROM shares s
          JOIN resources r ON s.resource_id = r.id
          WHERE s.user_id = ?
        `,
          [userId],
        );

        // N+1 Problem: For each shared resource, process ancestors and fetch descendants
        for (const resource of sharedResources) {
          visibleIds.add(resource.id);

          // Add ancestors (parsed from stored path)
          parseAncestorPath(resource.ancestor_path).forEach((id) =>
            visibleIds.add(id),
          );

          // Another query for descendants of each shared resource
          const descendants = await sqlQuery(
            `
            WITH RECURSIVE tree AS (
              SELECT id FROM resources WHERE parent_id = ?
              UNION ALL
              SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
            )
            SELECT id FROM tree
          `,
            [resource.id],
          );
          descendants.forEach((r) => visibleIds.add(r.id));
        }

        return Array.from(visibleIds);
      }

      async function getCounters() {
        let counters = await sqlQueryOne(
          `SELECT * FROM counters WHERE id = 'main'`,
        );
        if (!counters) {
          await sqlRun(
            `INSERT INTO counters (id, folder_count, file_count, user_count, resource_count)
             VALUES ('main', 1, 0, 1, 1)`,
          );
          counters = {
            folder_count: 1,
            file_count: 0,
            user_count: 1,
            resource_count: 1,
          };
        }
        return {
          folder: counters.folder_count,
          file: counters.file_count,
          user: counters.user_count,
          resource: counters.resource_count,
        };
      }

      async function updateCounters(counters) {
        await sqlRun(
          `UPDATE counters SET folder_count = ?, file_count = ?, user_count = ?, resource_count = ?
           WHERE id = 'main'`,
          [counters.folder, counters.file, counters.user, counters.resource],
        );
      }

      // Check if resource is only visible as ancestor (using cache)
      function isAncestorOnlyCached(resourceId, userId) {
        const user = cache.users.find((u) => u.id === userId);
        if (user.type === "admin") return false;

        const resource = cache.resources.find((r) => r.id === resourceId);
        if (resource.owner_id === userId) return false;

        // Check if directly shared with user
        if (
          cache.shares.some(
            (s) => s.resource_id === resourceId && s.user_id === userId,
          )
        ) {
          return false;
        }

        // Check if this resource is an ancestor of a shared resource
        const userShares = cache.shares.filter((s) => s.user_id === userId);
        for (const share of userShares) {
          const sharedResource = cache.resources.find(
            (r) => r.id === share.resource_id,
          );
          if (sharedResource) {
            const ancestorIds = parseAncestorPath(sharedResource.ancestor_path);
            if (ancestorIds.includes(resourceId)) {
              return true;
            }
          }
        }

        return false;
      }

      // Refresh cache from DB (called when data changes)
      async function refreshCache() {
        cache.users = await sqlQuery(`SELECT * FROM users`);
        cache.resources = await sqlQuery(`SELECT * FROM resources`);
        cache.shares = await sqlQuery(`SELECT * FROM shares`);
        cache.visibleIds = await getVisibleResourceIds(activeUserId);

        // RBAC: Load permissions with access_type for O(1) lookups
        if (implementationMode === "rbac") {
          const perms = await sqlQuery(
            `SELECT resource_id, access_type FROM permissions WHERE user_id = ?`,
            [activeUserId],
          );
          cache.permissions = {};
          for (const p of perms) {
            cache.permissions[p.resource_id] = p.access_type;
          }
        } else {
          cache.permissions = {};
        }

        cache.dirty = false;
      }

      // Render functions
      async function renderTabs() {
        const users = cache.users;

        tabsEl.innerHTML =
          users
            .map(
              (user) => `
          <button class="tab ${user.id === activeUserId ? "active" : ""}" data-user-id="${user.id}">
            ${user.name}
          </button>
        `,
            )
            .join("") + `<button class="tab add-user">+ Add User</button>`;

        tabsEl.querySelectorAll(".tab[data-user-id]").forEach((tab) => {
          tab.addEventListener("click", async () => {
            activeUserId = parseInt(tab.dataset.userId);
            // Refresh cache for new user's visibility and permissions
            await refreshCache();
            if (
              !cache.visibleIds.includes(selectedResourceId) &&
              cache.visibleIds.length > 0
            ) {
              selectedResourceId = cache.visibleIds[0];
            }
            await render();
          });
        });

        tabsEl
          .querySelector(".tab.add-user")
          .addEventListener("click", async () => {
            const counters = await getCounters();
            counters.user++;
            counters.resource++;

            const newUserId = counters.user;
            const newUserName = `User ${counters.user}`;

            await sqlRun(
              `INSERT INTO users (id, name, type) VALUES (?, ?, 'standard')`,
              [newUserId, newUserName],
            );

            const newFolderName = `${newUserName}'s Folder`;
            await sqlRun(
              `INSERT INTO resources (id, type, name, parent_id, ancestor_path, owner_id)
               VALUES (?, 'folder', ?, NULL, '', ?)`,
              [counters.resource, newFolderName, newUserId],
            );

            await updateCounters(counters);

            // RBAC: Initialize permissions for new user (owns their root folder)
            if (implementationMode === "rbac") {
              await grantPermissionOnCreate(counters.resource, newUserId);
            }

            activeUserId = newUserId;
            selectedResourceId = counters.resource;
            await refreshCache();
            await render();
          });
      }

      async function renderUserType() {
        const user = cache.users.find((u) => u.id === activeUserId);
        userTypeEl.innerHTML = `
          <label>
            <input type="radio" name="userType" value="admin" ${user.type === "admin" ? "checked" : ""}>
            Admin
          </label>
          <label>
            <input type="radio" name="userType" value="standard" ${user.type === "standard" ? "checked" : ""}>
            Standard
          </label>
        `;

        userTypeEl.querySelectorAll('input[type="radio"]').forEach((radio) => {
          radio.addEventListener("change", async () => {
            await sqlRun(`UPDATE users SET type = ? WHERE id = ?`, [
              radio.value,
              activeUserId,
            ]);

            // RBAC: Rebuild permissions when role changes
            if (implementationMode === "rbac") {
              await rebuildUserPermissions(activeUserId);
            }

            await refreshCache();
            await render();
          });
        });
      }

      async function renderActions() {
        const selected = cache.resources.find(
          (r) => r.id === selectedResourceId,
        );
        const isFolder = selected && selected.type === "folder";

        // Determine permissions - RBAC uses cached access_type, naive calculates
        let canCreate = false;
        let canShare = false;

        if (selected) {
          if (implementationMode === "rbac") {
            // RBAC: O(1) lookup from cached permissions
            const accessType = cache.permissions[selected.id];
            // Only owner can create or share
            canCreate = accessType === "owner" && isFolder;
            canShare = accessType === "owner";
          } else {
            // Naive: Must calculate ownership
            const isOwner = selected.owner_id === activeUserId;
            // Only owner can create or share
            canCreate = isFolder && isOwner;
            canShare = isOwner;
          }
        }

        actionsEl.innerHTML = `
          <button class="btn" id="addFolderBtn" ${!canCreate ? "disabled" : ""}>+ Add Folder</button>
          <button class="btn" id="addFileBtn" ${!canCreate ? "disabled" : ""}>+ Add File</button>
          <div class="share-container">
            <button class="btn" id="shareBtn" ${!canShare ? "disabled" : ""}>Share</button>
            <div class="share-dropdown" id="shareDropdown"></div>
          </div>
        `;

        const addFolderBtn = document.getElementById("addFolderBtn");
        const addFileBtn = document.getElementById("addFileBtn");
        const shareBtn = document.getElementById("shareBtn");
        const shareDropdown = document.getElementById("shareDropdown");

        addFolderBtn.addEventListener("click", async () => {
          if (!canCreate) return;
          const counters = await getCounters();
          counters.folder++;
          counters.resource++;

          // Build ancestor path: parent's path + parent's id
          const ancestorPath = selected.ancestor_path
            ? `${selected.ancestor_path},${selected.id}`
            : `${selected.id}`;

          await sqlRun(
            `INSERT INTO resources (id, type, name, parent_id, ancestor_path, owner_id)
             VALUES (?, 'folder', ?, ?, ?, ?)`,
            [
              counters.resource,
              `Folder ${counters.folder}`,
              selected.id,
              ancestorPath,
              activeUserId,
            ],
          );
          await updateCounters(counters);

          // RBAC: Grant permission for the new resource
          if (implementationMode === "rbac") {
            await grantPermissionOnCreate(counters.resource, activeUserId);
          }

          await refreshCache();
          await render();
        });

        addFileBtn.addEventListener("click", async () => {
          if (!canCreate) return;
          const counters = await getCounters();
          counters.file++;
          counters.resource++;

          // Build ancestor path: parent's path + parent's id
          const ancestorPath = selected.ancestor_path
            ? `${selected.ancestor_path},${selected.id}`
            : `${selected.id}`;

          await sqlRun(
            `INSERT INTO resources (id, type, name, parent_id, ancestor_path, owner_id)
             VALUES (?, 'file', ?, ?, ?, ?)`,
            [
              counters.resource,
              `File ${counters.file}`,
              selected.id,
              ancestorPath,
              activeUserId,
            ],
          );
          await updateCounters(counters);

          // RBAC: Grant permission for the new resource
          if (implementationMode === "rbac") {
            await grantPermissionOnCreate(counters.resource, activeUserId);
          }

          await refreshCache();
          await render();
        });

        shareBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const isOpen = shareDropdown.classList.contains("open");
          shareDropdown.classList.toggle("open", !isOpen);

          if (!isOpen) {
            const otherUsers = cache.users.filter(
              (u) => u.id !== selected.owner_id,
            );

            shareDropdown.innerHTML =
              otherUsers
                .map(
                  (u) => `
              <div class="share-option" data-user-id="${u.id}">${u.name}</div>
            `,
                )
                .join("") +
              `<div class="share-option new-user" data-new-user="true">+ New User</div>`;

            shareDropdown.querySelectorAll(".share-option").forEach((opt) => {
              opt.addEventListener("click", async (e) => {
                e.stopPropagation();
                let targetUserId;

                if (opt.dataset.newUser) {
                  const counters = await getCounters();
                  counters.user++;
                  counters.resource++;

                  const newUserId = counters.user;
                  const newUserName = `User ${counters.user}`;

                  await sqlRun(
                    `INSERT INTO users (id, name, type) VALUES (?, ?, 'standard')`,
                    [newUserId, newUserName],
                  );

                  await sqlRun(
                    `INSERT INTO resources (id, type, name, parent_id, ancestor_path, owner_id)
                     VALUES (?, 'folder', ?, NULL, '', ?)`,
                    [counters.resource, `${newUserName}'s Folder`, newUserId],
                  );

                  await updateCounters(counters);
                  targetUserId = newUserId;

                  // RBAC: Grant permission for new user's root folder
                  if (implementationMode === "rbac") {
                    await grantPermissionOnCreate(counters.resource, newUserId);
                  }
                } else {
                  targetUserId = parseInt(opt.dataset.userId);
                }

                // Check if already shared using cache
                if (
                  !cache.shares.some(
                    (s) =>
                      s.resource_id === selected.id &&
                      s.user_id === targetUserId,
                  )
                ) {
                  await sqlRun(
                    `INSERT INTO shares (resource_id, user_id) VALUES (?, ?)`,
                    [selected.id, targetUserId],
                  );

                  // RBAC: Grant permissions for shared resource
                  if (implementationMode === "rbac") {
                    await grantPermissionsOnShare(selected.id, targetUserId);
                  }
                }

                shareDropdown.classList.remove("open");
                await refreshCache();
                await render();
              });
            });
          }
        });

        document.addEventListener("click", () => {
          shareDropdown.classList.remove("open");
        });
      }

      async function renderTree() {
        if (cache.visibleIds.length === 0) {
          treeEl.innerHTML =
            '<div class="empty-message">No files or folders to display</div>';
          return;
        }

        function renderNode(parentId) {
          const children = cache.resources.filter(
            (r) => r.parent_id === parentId && cache.visibleIds.includes(r.id),
          );

          if (children.length === 0) return "";

          let html = "";
          for (const resource of children) {
            const isSelected = resource.id === selectedResourceId;
            const sharedWithUsers = cache.shares
              .filter((s) => s.resource_id === resource.id)
              .map((s) => cache.users.find((u) => u.id === s.user_id))
              .filter(Boolean);
            const icon = resource.type === "folder" ? "ðŸ“" : "ðŸ“„";
            const childrenHtml = renderNode(resource.id);
            const isOwner = resource.owner_id === activeUserId;

            let sharedBadge = "";
            if (sharedWithUsers.length > 0) {
              sharedBadge = isOwner
                ? `<span class="shared-badge">shared with: ${sharedWithUsers.map((u) => u.name).join(", ")}</span>`
                : `<span class="shared-badge">shared</span>`;
            }

            html += `
              <div class="tree-item ${isSelected ? "selected" : ""}" data-resource-id="${resource.id}">
                <span class="icon">${icon}</span>
                <span class="name">${resource.name}</span>
                ${sharedBadge}
              </div>
              ${childrenHtml ? `<div class="tree-children">${childrenHtml}</div>` : ""}
            `;
          }
          return html;
        }

        treeEl.innerHTML = renderNode(null);

        treeEl.querySelectorAll(".tree-item").forEach((item) => {
          item.addEventListener("click", () => {
            selectedResourceId = parseInt(item.dataset.resourceId);
            // No DB queries - just re-render from cache
            renderFromCache();
          });
        });
      }

      // Fast render from cache (no DB queries)
      function renderFromCache() {
        renderTabs();
        renderUserType();
        renderActions();
        renderTree();
      }

      async function render() {
        await renderTabs();
        await renderUserType();
        await renderActions();
        await renderTree();
      }

      // Initialize database with seed data
      async function initDB() {
        // Clear all tables (SQLite way)
        sqlRunSync(`DELETE FROM permissions`);
        sqlRunSync(`DELETE FROM shares`);
        sqlRunSync(`DELETE FROM resources`);
        sqlRunSync(`DELETE FROM users`);
        sqlRunSync(`DELETE FROM counters`);

        // Reset stats
        stats.reads = 0;
        stats.writes = 0;
        stats.scanned = 0;
        statsStartTime = Date.now();

        // Reset UI state
        activeUserId = 1;
        selectedResourceId = 1;

        // Create initial user
        await sqlRun(
          `INSERT INTO users (id, name, type) VALUES (1, 'User 1', 'standard')`,
        );

        // Create initial root folder
        await sqlRun(
          `INSERT INTO resources (id, type, name, parent_id, ancestor_path, owner_id)
           VALUES (1, 'folder', 'User 1''s Folder', NULL, '', 1)`,
        );

        // Create initial counters
        await sqlRun(
          `INSERT INTO counters (id, folder_count, file_count, user_count, resource_count)
           VALUES ('main', 1, 0, 1, 1)`,
        );

        // RBAC: Grant permission for first user's root folder
        if (implementationMode === "rbac") {
          await grantPermissionOnCreate(1, 1);
        }

        // Load cache and render
        await refreshCache();
        renderFromCache();
      }

      async function init() {
        await initSQL();

        // Set up implementation toggle
        document.querySelectorAll('input[name="impl"]').forEach((radio) => {
          radio.addEventListener("change", async () => {
            implementationMode = radio.value;
            await initDB();
          });
        });

        // Update stats display every 60 seconds to reset counters
        setInterval(updateStatsDisplay, 60000);

        await initDB();
      }

      init();
    </script>
  </body>
</html>
