<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" sizes="32x32" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@600;700&family=Literata:wght@300;400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
    />
    <title>Blog > Permission Systems for Enterprise that Scale</title>
    <meta
      name="description"
      content="Learn how to implement permission systems that scale for enterprise customers. From naive read-time queries to RBAC with write-time permissions, with interactive demos."
    />
    <meta name="author" content="Elio Capella SÃ¡nchez" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2025-12-12T00:00:00+01:00"
    />
    <meta
      property="og:url"
      content="https://eliocapella.com/blog/permission-systems-for-enterprise/"
    />
    <meta
      property="og:title"
      content="Permission Systems for Enterprise that Scale"
    />
    <meta
      property="og:description"
      content="Learn how to implement permission systems that scale for enterprise customers. From naive read-time queries to RBAC with write-time permissions, with interactive demos."
    />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta
      property="twitter:url"
      content="https://eliocapella.com/blog/permission-systems-for-enterprise/"
    />
    <meta
      property="twitter:title"
      content="Permission Systems for Enterprise that Scale"
    />
    <meta
      property="twitter:description"
      content="Learn how to implement permission systems that scale for enterprise customers. From naive read-time queries to RBAC with write-time permissions, with interactive demos."
    />
    <style>
      .split-layout {
        display: flex;
        flex-direction: row;
        min-height: 100vh;
        justify-content: center;
        gap: 3rem;
      }

      .blog-content {
        flex: 0 1 800px;
        max-width: 800px;
        padding: 2rem 1rem;
        overflow-y: auto;
      }

      .demo-panel {
        flex: 0 0 auto;
        position: sticky;
        top: 0;
        height: 100vh;
        display: flex;
        align-items: center;
      }

      .demo-panel iframe {
        width: 634px;
        height: auto;
        aspect-ratio: 634 / 500;
        border: none;
      }

      /* Override default body padding when using split layout */
      body:has(.split-layout) {
        padding: 0;
        max-width: none;
      }

      @media (max-width: 1200px) {
        .split-layout {
          flex-direction: column;
          height: 100vh;
          gap: 0;
        }

        .blog-content {
          flex: 1;
          width: 100%;
          max-width: 800px;
          margin: 0 auto;
          padding: 2rem 1rem;
          overflow-y: auto;
        }

        .demo-panel {
          flex: 0 0 auto;
          position: sticky;
          bottom: 0;
          height: auto;
          min-height: 0;
          padding-right: 0;
        }

        .demo-panel iframe {
          width: 100%;
          height: 45vh;
          min-height: 350px;
          aspect-ratio: auto;
        }
      }
    </style>
  </head>
  <body>
    <div class="split-layout">
      <div class="blog-content">
        <div class="blog-content-inner">
          <div class="page-header">
            <a href="/" class="home-nav">
              <img src="/selfie.jpg" alt="Go to home page" />
            </a>
            <h1>Permission Systems for Enterprise that Scale</h1>
            <p class="post-date">December 12, 2025</p>
          </div>

          <p>
            Many startups eventually gravitate towards enterprise customers for
            bigger tickets and long-term contracts. As enterprise customers
            start using your product they soon demand advanced permissions
            systems to manage their different user roles and access levels. A
            naive implementation of the permission checks works perfectly fine
            at first but as they start to use more and more your platform the
            amount of data, users and relationships will put that implementation
            to the test. Soon your biggest paying customer will be threatening
            to churn because your app is just too slow.
          </p>
          <p>
            To illustrate this problem we will I've setup a simple example.
            Imagine an app which has folders and files where an 'admin' can see
            all folders and files but 'standard' users can only see files and
            folders they've created or have been shared with them.
          </p>

          <h2>The Naive Approach (read-time permission queries)</h2>

          <p>
            Your first intuition will be to query the database on every request
            to calculate the permissions and the data that the user can access.
            First you will check the role of the user in the team, is the user
            an admin or an standard user. If the user is not at admin then query
            for all the resources the user has created or has been shared with
            them.
          </p>
          <p>
            First part is straightforward, if you are an admin return all
            resources:
          </p>
          <pre><code class="language-js">const user = await sqlQueryOne(`SELECT * FROM users WHERE id = ?`, [
  userId,
]);

// Admin: Fetch all resources
if (user.type === "admin") {
  return await sqlQuery(`SELECT id FROM resources`);
}</code></pre>
          <p>
            For standard users you will need to query for resources created by
            them, if the resource is a folder you will have access to all of its
            descendants:
          </p>
          <pre><code class="language-js">const ownedResources = await sqlQuery(
  `SELECT id FROM resources WHERE owner_id = ?`,
  [userId],
);

// For each owned resource, fetch descendants recursively
for (const resource of ownedResources) {
  accessibleResources.add(resource);

  const descendants = await sqlQuery(
    `
    WITH RECURSIVE tree AS (
      SELECT id FROM resources WHERE parent_id = ?
      UNION ALL
      SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
    )
    SELECT id FROM tree
  `,
    [resource.id],
  );
  accessibleResources.add(...descendants);
}</code></pre>

          <p>
            We can start to see recursive queries, as we own more and more
            resources and there is more and more nesting the queries will get
            slower.<br />
            Finally we include all shared resources, their descendants if you've
            been shared a folder, plus their ancestors to show the full path:
          </p>

          <pre><code class="language-js">const sharedResources = await sqlQuery(
  `
  SELECT r.id, r.ancestor_path
  FROM shares s
  JOIN resources r ON s.resource_id = r.id
  WHERE s.user_id = ?
`,
  [userId],
);

// For each shared resource, fetch ascenstors and descendants
for (const resource of sharedResources) {
  accessibleResources.add(resource);

  // Query ancestors to show full path
  const ancestors = await sqlQuery(
    `
    WITH RECURSIVE ancestors AS (
      SELECT parent_id FROM resources WHERE id = ?
      UNION ALL
      SELECT r.parent_id FROM resources r JOIN ancestors a ON r.id = a.parent_id
      WHERE r.parent_id IS NOT NULL
    )
    SELECT parent_id as id FROM ancestors WHERE parent_id IS NOT NULL
  `,
    [resourceId],
  );
  accessibleResources.add(...ancestors);

  // Another query for descendants of each shared resource
  const descendants = await sqlQuery(
    `
    WITH RECURSIVE tree AS (
      SELECT id FROM resources WHERE parent_id = ?
      UNION ALL
      SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
    )
    SELECT id FROM tree
  `,
    [resource.id],
  );
  accessibleResources.add(...ancestors);
}</code></pre>
          <p>
            The code is easy to follow but the number of queries and recursive
            queries in this case with the nested folder setup will quickly
            become a bottleneck as you scale.
          </p>

          <h2>RBAC (write-time permission queries)</h2>
          <p>
            Because we read more than we write, it make sense to optimize for
            reads. How does this look like? With
            <a
              href="https://en.wikipedia.org/wiki/Role-based_access_control"
              target="_blank"
              >Role Based Access Control</a
            >
            we will store the precomputed roles in the database, linking users
            with resources:
          </p>

          <pre><code class="language-js">// RBAC: Pre-computed permissions
// access_type: 'owner' (full control), 'shared' (read only), 'path_only' (visible but no access)
db.run(`
  CREATE TABLE permissions (
    user_id INTEGER NOT NULL,
    resource_id INTEGER NOT NULL,
    access_type TEXT NOT NULL DEFAULT 'path_only',
    PRIMARY KEY (user_id, resource_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (resource_id) REFERENCES resources(id)
  )
`);</code></pre>
          <p>Now when querying for resources we can simply do:</p>
          <pre><code class="language-js">const resources = await sqlQuery(
  `SELECT r.* FROM resources r
   JOIN permissions p ON r.id = p.resource_id
   WHERE p.user_id = ?`,
  [userId],
);
</code></pre>
          <p>
            That's it! No recursive queries, no multiple queries, just a simple
            join. Can't get faster than that as it is easy to index too.<br />Let's
            see how to maintain the permissions table. On every new resource we
            need to grant the owner full access:
          </p>

          <pre><code class="language-js">await sqlRun(
  `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'owner')`,
  [ownerId, resourceId],
);</code></pre>
          <p>
            That was easy but some more complex logic is needed when sharing
            resources:
          </p>
          <pre><code class="language-js">// Add the shared resource itself with 'shared' access
await sqlRun(
  `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
  [userId, resourceId],
);

// Add ancestors for path visibility (path_only - no actual access)
const ancestorIds = await getAncestorIds(resourceId);
for (const ancestorId of ancestorIds) {
  await sqlRun(
    `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'path_only')`,
    [userId, ancestorId],
  );
}

// Add all descendants with 'shared' access
const descendantIds = await getDescendantIds(resourceId);
for (const descId of descendantIds) {
  await sqlRun(
    `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
    [userId, descId],
  );
}
</code></pre>
          <p>
            You can clearly see the trade-off here, we moved the complexity from
            read-time to write-time. Every time a resource is created or shared
            we need to update the permissions table accordingly. We added a
            point of failure as the permission table and be out of sync with the
            actual data.
          </p>

          <h2>Real-world example: PostHog</h2>
          <p>
            This is not just theory.
            <a href="https://posthog.com/" target="_blank">PostHog</a>, the
            popular open-source product analytics platform, uses the exact same
            approach. They have an
            <a
              href="https://github.com/PostHog/posthog/blob/master/ee/models/rbac/access_control.py"
              target="_blank"
              ><code>AccessControl</code></a
            >
            model that stores pre-computed permissions:
          </p>

          <pre><code class="language-python"># PostHog: ee/models/rbac/access_control.py
class AccessControl(models.Model):
    team = models.ForeignKey("posthog.Team", on_delete=models.CASCADE)
    access_level = models.CharField(max_length=32)  # 'none', 'viewer', 'editor'
    resource = models.CharField(max_length=32)      # 'dashboard', 'feature_flag', etc.
    resource_id = models.CharField(null=True)       # null = all, UUID = specific object

    # Can be scoped to a user or a role
    organization_member = models.ForeignKey(..., null=True)
    role = models.ForeignKey("Role", null=True)</code></pre>

          <p>
            When listing resources, they simply
            <a
              href="https://github.com/PostHog/posthog/blob/master/posthog/rbac/user_access_control.py#L700"
              target="_blank"
              >filter the queryset</a
            >
            based on these pre-computed permissions:
          </p>

          <pre><code class="language-python"># PostHog: posthog/rbac/user_access_control.py
def filter_queryset_by_access_level(self, queryset, ...):
    # Get pre-computed access controls from cache
    access_controls = self._get_access_controls(filters)

    # Build sets of allowed/blocked resource IDs
    for access_control in access_controls:
        if access_control.access_level != NO_ACCESS_LEVEL:
            allowed_resource_ids.add(access_control.resource_id)
        else:
            blocked_resource_ids.add(access_control.resource_id)

    # Filter queryset - no recursive queries needed!
    return queryset.filter(id__in=allowed_resource_ids)</code></pre>

          <p>
            They also cache the access controls during a request to avoid
            repeated database lookups:
          </p>

          <pre><code class="language-python"># PostHog: posthog/rbac/user_access_control.py
def _get_access_controls(self, filters):
    key = json.dumps(filters, sort_keys=True)
    if key not in self._cache:
        self._cache[key] = list(AccessControl.objects.filter(...))
    return self._cache[key]</code></pre>

          <p>
            The pattern is clear: pre-compute permissions at write-time, store
            them in a dedicated table, and filter with simple lookups at
            read-time.
          </p>

          <!-- TODO: Section 3 - Why ABAC isn't suitable for list queries -->
          <h2>What about ABAC?</h2>
          <p>
            If you research on ways to implement permission systems you will
            often find
            <a
              href="https://en.wikipedia.org/wiki/Attribute-based_access_control"
              target="_blank"
              >Attribute-Based Access Control</a
            >
            as a recommended approach. ABAC is great when you need to make
            complex decisions on whether a user can access a specific resource
            or not. Figma showed how they handle permissions and this is an
            example of
            <a
              href="https://www.figma.com/blog/how-we-rolled-out-our-own-permissions-dsl-at-figma/"
              target="_blank"
              >ABAC in action.</a
            >
          </p>
          <p>
            The main difference with our naive approach is that ABAC approaches
            offer a declaritive way of defining the rules and policies behind
            the permission checks. The engine will convert those policies into
            queries and code to execute them at read-time. Here is an example of
            how those rules could look like for our example:
          </p>
          <pre><code># Rule 1: Admins can access everything
allow if {
    input.user.type == "admin"
}

# Rule 2: Owners can access their resources
allow if {
    input.resource.owner_id == input.user.id
}

# Rule 3: Users can access resources shared with them
allow if {
    some share in data.shares
    share.resource_id == input.resource.id
    share.user_id == input.user.id
}

# ...
</code></pre>
          <p>
            This approach is very clear and composable, it works great for
            single resource access checks, "can user x access resource y?". It
            struggles when listing resources as we would need to execute the
            policies for each resource and we can't directly query the resources
            table with simple filters.
          </p>

          <!-- TODO: Section 4 - Adding the list of ascendants, alternative approach is folder closure tables -->

          <!-- TODO: Conclusion -->
        </div>
      </div>
      <div class="demo-panel">
        <iframe src="./demo.html" title="Permission System Demo"></iframe>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  </body>
</html>
