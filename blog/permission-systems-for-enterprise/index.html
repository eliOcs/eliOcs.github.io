<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" sizes="32x32" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@600;700&family=Literata:wght@300;400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
    />
    <title>Blog > Permission Systems for Enterprise that Scale</title>
    <meta
      name="description"
      content="Permission checks that query on every request will break at scale. Learn how pre-computing permissions at write-time enables O(1) reads, with working SQL examples and an interactive demo."
    />
    <meta name="author" content="Elio Capella Sánchez" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2025-12-12T00:00:00+01:00"
    />
    <meta
      property="og:url"
      content="https://eliocapella.com/blog/permission-systems-for-enterprise/"
    />
    <meta
      property="og:title"
      content="Permission Systems for Enterprise that Scale"
    />
    <meta
      property="og:description"
      content="Permission checks that query on every request will break at scale. Learn how pre-computing permissions at write-time enables O(1) reads, with working SQL examples and an interactive demo."
    />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta
      property="twitter:url"
      content="https://eliocapella.com/blog/permission-systems-for-enterprise/"
    />
    <meta
      property="twitter:title"
      content="Permission Systems for Enterprise that Scale"
    />
    <meta
      property="twitter:description"
      content="Permission checks that query on every request will break at scale. Learn how pre-computing permissions at write-time enables O(1) reads, with working SQL examples and an interactive demo."
    />
    <style>
      /* Override default body padding when using split layout */
      body:has(.split-layout) {
        padding: 0;
        max-width: none;
      }

      /* Stacked layout (default - narrow screens) */
      .split-layout {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        padding-bottom: 45vh;
      }

      .blog-content {
        flex: 1;
        max-width: 800px;
        width: 100%;
        margin: 0 auto;
        padding: 2rem 1rem;
      }

      .demo-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 45vh;
        background: var(--base00);
        transition: transform 0.3s ease;
        border-top: 1px solid var(--base02);
      }

      .demo-panel.hidden {
        transform: translateY(100%);
      }

      .demo-panel iframe {
        width: 100%;
        height: 100%;
        max-width: 800px;
        margin: 0 auto;
        display: block;
        border: none;
      }

      .demo-toggle {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        width: var(--icon-size-desktop);
        height: var(--icon-size-desktop);
        border-radius: 50%;
        background-color: transparent;
        border: none;
        cursor: pointer;
        color: var(--base05);
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        z-index: 100;
        transition: background-color 0.2s ease, transform 0.2s ease, bottom 0.3s ease;
      }

      .demo-toggle:hover {
        background-color: var(--base01);
      }

      .demo-toggle:not(.demo-collapsed) {
        bottom: calc(45vh + 1rem);
      }

      .demo-toggle-icon {
        transition: transform 0.3s ease;
      }

      .demo-toggle.demo-collapsed .demo-toggle-icon {
        transform: rotate(180deg);
      }

      /* Side-by-side layout (wide screens) */
      @media (min-width: 1700px) {
        .split-layout {
          flex-direction: row;
          min-height: 100vh;
          padding-bottom: 0;
          gap: 3rem;
        }

        .blog-content {
          flex: 0 1 800px;
          margin-left: auto;
          margin-right: 0;
        }

        .demo-panel,
        .demo-panel.hidden {
          flex: 0 1 800px;
          position: sticky;
          top: 0;
          left: auto;
          right: auto;
          bottom: auto;
          height: 100vh;
          display: flex;
          align-items: center;
          margin-left: 0;
          margin-right: auto;
          background: transparent;
          transform: none;
          border-top: none;
        }

        .demo-panel iframe {
          height: 85vh;
          max-height: 800px;
          max-width: none;
        }

        .demo-toggle {
          display: none;
        }
      }

      @media (max-width: 768px) {
        .demo-toggle {
          width: var(--icon-size-mobile);
          height: var(--icon-size-mobile);
        }
      }
    </style>
  </head>
  <body>
    <div class="split-layout">
      <div class="blog-content">
        <div class="blog-content-inner">
          <div class="page-header">
            <a href="/" class="home-nav">
              <img src="/selfie.jpg" alt="Go to home page" />
            </a>
            <h1>Permission Systems for Enterprise that Scale</h1>
            <p class="post-date">December 12, 2025</p>
          </div>

          <p>
            Many startups eventually gravitate towards enterprise customers for
            bigger tickets and long-term contracts. As enterprise customers
            start using your product, they soon demand advanced permission
            systems to manage their different user roles and access levels. A
            naive implementation of permission checks works perfectly fine at
            first, but as they use your platform more and more, the amount of
            data, users, and relationships will put that implementation to the
            test. Soon your biggest paying customer will be threatening to churn
            because your app is just <em>too slow</em>.
          </p>
          <p>
            To illustrate this problem, I've set up a simple example. Imagine an
            app with folders and files where an admin can see all folders and
            files, but standard users can only see files and folders they've
            created or that have been shared with them.
          </p>

          <h2>The Naive Approach (read-time permission queries)</h2>

          <p>
            Your first intuition will be to query the database on every request
            to calculate the permissions and the data that the user can access.
            First, you check the role of the user: is the user an admin or a
            standard user? If the user is not an admin, then query for all the
            resources the user has created or that have been shared with them.
          </p>
          <p>
            The first part is straightforward: if you are an admin, return all
            resources.
          </p>
          <pre><code class="language-js">const user = await sqlQueryOne(`SELECT * FROM users WHERE id = ?`, [
  userId,
]);

// Admin: Fetch all resources
if (user.type === "admin") {
  return await sqlQuery(`SELECT * FROM resources`);
}</code></pre>
          <p>
            For standard users, you need to query for resources created by them.
            If the resource is a folder, you will have access to all of its
            descendants.
          </p>
          <pre><code class="language-js">const accessibleResources = [];

const ownedResources = await sqlQuery(
  `SELECT * FROM resources WHERE owner_id = ?`,
  [userId],
);

// For each owned resource, fetch descendants recursively
for (const resource of ownedResources) {
  accessibleResources.push(resource);

  const descendants = await sqlQuery(
    `
    WITH RECURSIVE tree AS (
      SELECT id FROM resources WHERE parent_id = ?
      UNION ALL
      SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
    )
    SELECT r.* FROM resources r JOIN tree t ON r.id = t.id
  `,
    [resource.id],
  );
  accessibleResources.push(...descendants);
}</code></pre>

          <p>
            We can already see recursive queries appearing. As we own more
            resources with deeper nesting, the queries will get slower.
          </p>
          <p>
            Finally, we include all shared resources, their descendants if a
            folder was shared, plus their ancestors to show the full path.
          </p>

          <pre><code class="language-js">const sharedResources = await sqlQuery(
  `
  SELECT r.*
  FROM shares s
  JOIN resources r ON s.resource_id = r.id
  WHERE s.user_id = ?
`,
  [userId],
);

// For each shared resource, fetch ancestors and descendants
for (const resource of sharedResources) {
  accessibleResources.push(resource);

  // Query ancestors to show full path
  const ancestors = await sqlQuery(
    `
    WITH RECURSIVE ancestors AS (
      SELECT parent_id FROM resources WHERE id = ?
      UNION ALL
      SELECT r.parent_id FROM resources r JOIN ancestors a ON r.id = a.parent_id
      WHERE r.parent_id IS NOT NULL
    )
    SELECT r.* FROM resources r JOIN ancestors a ON r.id = a.parent_id
  `,
    [resource.id],
  );
  accessibleResources.push(...ancestors);

  // Another query for descendants of each shared resource
  const descendants = await sqlQuery(
    `
    WITH RECURSIVE tree AS (
      SELECT id FROM resources WHERE parent_id = ?
      UNION ALL
      SELECT r.id FROM resources r JOIN tree t ON r.parent_id = t.id
    )
    SELECT r.* FROM resources r JOIN tree t ON r.id = t.id
  `,
    [resource.id],
  );
  accessibleResources.push(...descendants);
}</code></pre>
          <p>
            The code is easy to follow, but the number of queries—especially
            recursive ones with nested folder structures—will quickly become a
            <strong>bottleneck</strong> as you scale.
          </p>

          <h2>RBAC (write-time permission queries)</h2>
          <p>
            Because we normally develop apps that
            <strong>read more than they write</strong>, it makes sense to
            optimize for reads. What does this look like? With
            <a
              href="https://en.wikipedia.org/wiki/Role-based_access_control"
              target="_blank"
              >Role Based Access Control</a
            >
            we store the pre-computed permissions in the database, linking users
            with resources:
          </p>

          <pre><code class="language-sql">-- RBAC: Pre-computed permissions
-- access_type: 'owner' (full control), 'shared' (read only), 'path_only' (visible but no access)
CREATE TABLE permissions (
  user_id INTEGER NOT NULL,
  resource_id INTEGER NOT NULL,
  access_type TEXT NOT NULL,
  PRIMARY KEY (user_id, resource_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (resource_id) REFERENCES resources(id)
);</code></pre>
          <p>Now, when querying for resources, we can simply do:</p>
          <pre><code class="language-js">const resources = await sqlQuery(
  `SELECT r.* FROM resources r
   JOIN permissions p ON r.id = p.resource_id
   WHERE p.user_id = ?`,
  [userId],
);
</code></pre>
          <p>
            That's it! No recursive queries, no multiple queries, just a simple
            join. It's as fast as it gets, and easy to index too.
          </p>
          <p>
            Let's see how to maintain the permissions table. On every new
            resource, we need to grant the owner full access:
          </p>

          <pre><code class="language-js">await sqlRun(
  `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'owner')`,
  [ownerId, resourceId],
);</code></pre>
          <p>
            That was easy, but some more complex logic is needed when sharing
            resources:
          </p>
          <pre><code class="language-js">// Add the shared resource itself with 'shared' access
await sqlRun(
  `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
  [userId, resourceId],
);

// Add ancestors for path visibility (path_only - no actual access)
const ancestorIds = await getAncestorIds(resourceId);
for (const ancestorId of ancestorIds) {
  await sqlRun(
    `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'path_only')`,
    [userId, ancestorId],
  );
}

// Add all descendants with 'shared' access
const descendantIds = await getDescendantIds(resourceId);
for (const descId of descendantIds) {
  await sqlRun(
    `INSERT OR IGNORE INTO permissions (user_id, resource_id, access_type) VALUES (?, ?, 'shared')`,
    [userId, descId],
  );
}
</code></pre>
          <p>
            You can clearly see the trade-off here: we moved the complexity from
            <strong>read-time</strong> to <strong>write-time</strong>. Every
            time a resource is created or shared, we need to update the
            permissions table accordingly. We added a point of failure, as the
            permissions table can get out of sync with the actual data.
          </p>

          <h2>Real-world example: PostHog</h2>
          <p>
            Although this is a simple example, while browsing the
            <a href="https://posthog.com/" target="_blank">PostHog</a> source
            code I found the exact same approach. They have an
            <a
              href="https://github.com/PostHog/posthog/blob/master/ee/models/rbac/access_control.py"
              target="_blank"
              ><code>AccessControl</code></a
            >
            model that stores pre-computed permissions:
          </p>

          <pre><code class="language-python"># PostHog: ee/models/rbac/access_control.py
class AccessControl(models.Model):
    team = models.ForeignKey("posthog.Team", on_delete=models.CASCADE)
    access_level = models.CharField(max_length=32)  # 'none', 'viewer', 'editor'
    resource = models.CharField(max_length=32)      # 'dashboard', 'feature_flag', etc.
    resource_id = models.CharField(null=True)       # null = all, UUID = specific object

    # Can be scoped to a user or a role
    organization_member = models.ForeignKey(..., null=True)
    role = models.ForeignKey("Role", null=True)</code></pre>

          <p>
            When listing resources, they simply
            <a
              href="https://github.com/PostHog/posthog/blob/master/posthog/rbac/user_access_control.py#L700"
              target="_blank"
              >filter the queryset</a
            >
            based on these pre-computed permissions:
          </p>

          <pre><code class="language-python"># PostHog: posthog/rbac/user_access_control.py
def filter_queryset_by_access_level(self, queryset, ...):
    # Get pre-computed access controls from cache
    access_controls = self._get_access_controls(filters)

    # Build sets of allowed/blocked resource IDs
    for access_control in access_controls:
        if access_control.access_level != NO_ACCESS_LEVEL:
            allowed_resource_ids.add(access_control.resource_id)
        else:
            blocked_resource_ids.add(access_control.resource_id)

    # Filter queryset - no recursive queries needed!
    return queryset.filter(id__in=allowed_resource_ids)</code></pre>

          <p>
            They also cache the access controls during a request to avoid
            repeated database lookups:
          </p>

          <pre><code class="language-python"># PostHog: posthog/rbac/user_access_control.py
def _get_access_controls(self, filters):
    key = json.dumps(filters, sort_keys=True)
    if key not in self._cache:
        self._cache[key] = list(AccessControl.objects.filter(...))
    return self._cache[key]</code></pre>

          <p>
            The pattern is clear: <strong>pre-compute</strong> permissions at
            write-time, <strong>store</strong> them in a dedicated table, and
            <strong>filter</strong> with simple lookups at read-time.
          </p>

          <h2>What about ABAC?</h2>
          <p>
            If you research ways to implement permission systems, you will often
            find
            <a
              href="https://en.wikipedia.org/wiki/Attribute-based_access_control"
              target="_blank"
              >Attribute-Based Access Control</a
            >
            as a recommended approach. ABAC is great when you need to make
            complex decisions on whether a user can access a specific resource
            or not. Figma showed how they handle permissions, and this is an
            example of
            <a
              href="https://www.figma.com/blog/how-we-rolled-out-our-own-permissions-dsl-at-figma/"
              target="_blank"
              >ABAC in action.</a
            >
          </p>
          <p>
            The main difference from our naive approach is that ABAC offers a
            declarative way of defining the rules and policies behind the
            permission checks. The engine will convert those policies into
            queries and code to execute them at read-time. Here is an example of
            how those rules could look for our example:
          </p>
          <pre><code class="language-none"># Rule 1: Admins can access everything
allow if {
    input.user.type == "admin"
}

# Rule 2: Owners can access their resources
allow if {
    input.resource.owner_id == input.user.id
}

# Rule 3: Users can access resources shared with them
allow if {
    some share in data.shares
    share.resource_id == input.resource.id
    share.user_id == input.user.id
}

# ...
</code></pre>
          <p>
            This approach is very clear and composable. It works great for
            single-resource access checks:
            <em>"can user X access resource Y?"</em> It struggles when listing
            resources, as we would need to execute the policies for each
            resource and can't directly query the resources table with simple
            filters.
          </p>

          <h2>Optimizing for hierarchical data</h2>
          <p>
            Both approaches still rely on recursive queries to traverse the
            folder hierarchy. In SaaS applications with deeply nested
            structures, these recursive queries can also become a bottleneck.
            There are two common patterns to eliminate them.
          </p>

          <h3>Materialized paths</h3>
          <p>
            A simple alternative is storing the full path as a string column on
            each resource.
          </p>
          <pre><code class="language-sql">ALTER TABLE resources ADD COLUMN path TEXT;

-- Example paths:
-- /1/           (root folder, id=1)
-- /1/5/         (child of root, id=5)
-- /1/5/12/      (grandchild, id=12)</code></pre>
          <p>Finding descendants becomes a prefix search.</p>
          <pre><code class="language-js">// All descendants of resource with path '/1/5/'
const descendants = await sqlQuery(
  `SELECT * FROM resources WHERE path LIKE ?`,
  [resource.path + "%"],
);

// All ancestors by parsing the path
const ancestorIds = resource.path.split("/").filter(Boolean);
const ancestors = await sqlQuery(
  `SELECT * FROM resources WHERE id IN (${ancestorIds.join(",")})`,
);</code></pre>
          <p>
            Materialized paths are easier to implement but can be tricky when
            moving resources between folders, as you need to update the path of
            all descendants. Closure tables handle moves more gracefully.
          </p>

          <h3>Closure tables</h3>
          <p>
            A closure table pre-computes all ancestor-descendant relationships.
            Instead of traversing the tree at query time, you store every
            possible path—another trade-off between read and write times.
          </p>
          <pre><code class="language-sql">CREATE TABLE resource_closure (
  ancestor_id INTEGER NOT NULL,
  descendant_id INTEGER NOT NULL,
  depth INTEGER NOT NULL,
  PRIMARY KEY (ancestor_id, descendant_id),
  FOREIGN KEY (ancestor_id) REFERENCES resources(id),
  FOREIGN KEY (descendant_id) REFERENCES resources(id)
);

-- /1/           (root folder, id=1)
INSERT INTO resource_closure VALUES (1, 1, 0);

-- /1/5/         (child of root, id=5)
INSERT INTO resource_closure VALUES (5, 5, 0);
INSERT INTO resource_closure VALUES (1, 5, 1);

-- /1/5/12/      (grandchild, id=12)
INSERT INTO resource_closure VALUES (12, 12, 0);
INSERT INTO resource_closure VALUES (5, 12, 1);
INSERT INTO resource_closure VALUES (1, 12, 2);</code></pre>
          <p>
            With this table, finding all descendants becomes a simple join with
            no recursion.
          </p>
          <pre><code class="language-js">// All descendants of a resource (instant lookup)
const descendants = await sqlQuery(
  `SELECT r.* FROM resources r
   JOIN resource_closure c ON r.id = c.descendant_id
   WHERE c.ancestor_id = ? AND c.depth > 0`,
  [resourceId],
);

// All ancestors of a resource (for showing the path)
const ancestors = await sqlQuery(
  `SELECT r.* FROM resources r
   JOIN resource_closure c ON r.id = c.ancestor_id
   WHERE c.descendant_id = ? AND c.depth > 0
   ORDER BY c.depth DESC`,
  [resourceId],
);</code></pre>
          <p>
            The trade-off is write complexity. When creating a resource, you
            must insert closure entries for all ancestors.
          </p>
          <pre><code class="language-js">// When creating a new resource under parentId
await sqlRun(
  `INSERT INTO resource_closure (ancestor_id, descendant_id, depth)
   SELECT ancestor_id, ?, depth + 1
   FROM resource_closure
   WHERE descendant_id = ?
   UNION ALL
   SELECT ?, ?, 0`,
  [newResourceId, parentId, newResourceId, newResourceId],
);</code></pre>

          <h2>Conclusion</h2>
          <p>
            The core trade-off is clear: you can pay the cost at read-time with
            recursive queries, or at write-time by maintaining a permissions
            index. Starting with the naive approach makes sense it's simpler to
            implement and debug.
          </p>
          <p>
            But when your enterprise customers start experiencing slow load
            times, the RBAC approach becomes worth the added complexity. The
            performance difference is significant enough that it can eliminate
            the need for other workarounds like aggressive caching or complex
            pagination.
          </p>
          <p>
            The main risk with pre-computed permissions is data getting
            <strong>out of sync</strong>. Plan for this by building a rebuild
            script from day one that can recompute all permissions from the
            source of truth. When bugs happen, and they will, you'll be glad you
            have it.
          </p>
        </div>
      </div>
      <div class="demo-panel" id="demoPanel">
        <iframe src="./demo.html" title="Permission System Demo"></iframe>
      </div>
      <div class="demo-toggle" id="demoToggle">
        <svg class="demo-toggle-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="6,9 12,15 18,9" />
        </svg>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script>
      document.getElementById('demoToggle').addEventListener('click', () => {
        document.getElementById('demoPanel').classList.toggle('hidden');
        document.getElementById('demoToggle').classList.toggle('demo-collapsed');
      });
    </script>
  </body>
</html>
